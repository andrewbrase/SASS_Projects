this keyword/ variable : Special variable that is 
created for every execution context (every function).
Takes the value of (points to) the "owner" of the 
function in which the this keyword is used.

this is NOT static. It depends on how the function 
is called, and its value is only assigned when the 
function is actually called.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
different ways in which functions can be called
1. as a method - a function attached to an object
Method this = <object that is calling the method>

const andrew = {
    name : 'andrew' ,
    year : 2000 ,
    calcAge : function() {
        return 2022 - this.year;
    }
};

andrew.calcAge();
---> 22

2. simple function call -> this = undefined
this is only valid for strict mode - if not in strict mode,
this will point to the global object - window object

3. Arrow functions -> this = <this of surrounding function 
(lexical this) - it gets picked up by the outer lexical 
scope of the arrow function>

4. event listener -> this = <DOM element that the handler is attached to>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Method borrowing - taking one method from one obj and adding it to another obj

const dave = {
    name : 'dave' ,
    birthyear : 1965 ,
    calcAge : function () {
        return this.name + ' is ' + (2022 - this.birthyear)
    }
}

//dave.calcAge()
//~~~
 const matilda = {
    name : 'matilda' ,
    birthyear : 2005
 }

matilda.calcAge = dave.calcAge;
matilda.calcAge()

---> matilda is 17
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
regular functions vs arrow functions & this

const jonas = {
    firstname : 'jonas' ,
    year : 1991 ,
    calcAge : function() {
        return 2022 - this.year
    } ,

    // trying to use an arrow function using the this keyword 
    greet : () => console.log(`hey ${this.firstname}`)
}

jonas.calcAge()
// ---> 31
jonas.greet()
// ---> hey undefined

*** AN arrow function does not get a THIS 
keyword - the parent scope of the greet method 
is the global scope

this is an object litteral, not a code block - it does
not get its own scope

the arrow function ends up ising the window object of the browser
***Don't use an arrow function as a method

~~~~~~~~~~~~~~~~~~~~~~~
this keyword downfall - function inside of a method

const john = {
    name : 'john' ,
    birthyear : 1992 ,
    isMellenial : function() {
        console.log(this.birthyear > 1981 && this.birthyear < 1996)
    }
}

john.isMellenial()
---> true
~~~

const john = {
    firstname : 'john' ,
    year : 1992 ,
    calcAge : function() {
        const isMellenial = function() {
            console.log(this.birthyear > 1981 && this.birthyear < 1996)
        }
        isMellenial()
        //return 2022 - this.year
    } 
}

john.calcAge()

/* regular functions have this keyword as undefined 
solution 1. use const self = this (outside of the isMellenial function)
inside of the function you can use self.year etc. */

Now in es6 we have a more modern solution - use an arrow function
soultion 2. an arrow function does not have its own this keyword,
it will use the this keyword of its parent scope
const isMellenial = () => {
    console.log(this.year)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Arguments keyword

const addExpr = function (a,b) {
    console.log(arguments)
    return a + b
}

addExpr(2,5)
---> Arguments(2) [2, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ]

It is completely legal to add more arguments

addExpr(2, 4, 6, 8)
---> Arguments(4) [2, 4, 6, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]

~~~ arguments keyword with arrow function
var addArrow = (a,b) => {
    console.log(arguments)
    return a + b
}

addArrow(2,4,6,8)

!!!
---> arguments is not defined

*** the arguments keyword only exists in 
regular functions and not arrow functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Primitives vs. Objects (Primitive vs. Reference Types)


--- JS Primitive types ---
        Number
        String
        Boolean
        Undefined
        Null
        Symbol
        BigInt

Reference types
--- Objects ---
    Object literal
    Arrays
    Functions
    Many more

the way that data is stored in memory - reference types

--- JS engine ---


Call Stack : where functions are executed (primitives are stored in call stack)
Heap : where objects & reference types are stored in memory


const me = {
    name : 'andrew',
    age : 22,
}
const friend = me;
// creating an identical obj named friend

friend.age = 27;
console.log(friend.age)
console.log(me.age)

!!!
// both ages are now 27 even though the friend.age was changed
---> 27
---> 27

why this happens -