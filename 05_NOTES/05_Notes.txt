this keyword/ variable : Special variable that is 
created for every execution context (every function).
Takes the value of (points to) the "owner" of the 
function in which the this keyword is used.

this is NOT static. It depends on how the function 
is called, and its value is only assigned when the 
function is actually called.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
different ways in which functions can be called
1. as a method - a function attached to an object
Method this = <object that is calling the method>

const andrew = {
    name : 'andrew' ,
    year : 2000 ,
    calcAge : function() {
        return 2022 - this.year;
    }
};

andrew.calcAge();
---> 22

2. simple function call -> this = undefined
this is only valid for strict mode - if not in strict mode,
this will point to the global object - window object

3. Arrow functions -> this = <this of surrounding function 
(lexical this) - it gets picked up by the outer lexical 
scope of the arrow function>

4. event listener -> this = <DOM element that the handler is attached to>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Method borrowing - taking one method from one obj and adding it to another obj

const dave = {
    name : 'dave' ,
    birthyear : 1965 ,
    calcAge : function () {
        return this.name + ' is ' + (2022 - this.birthyear)
    }
}

//dave.calcAge()
//~~~
 const matilda = {
    name : 'matilda' ,
    birthyear : 2005
 }

matilda.calcAge = dave.calcAge;
matilda.calcAge()

---> matilda is 17
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
regular functions vs arrow functions & this

const jonas = {
    firstname : 'jonas' ,
    year : 1991 ,
    calcAge : function() {
        return 2022 - this.year
    } ,

    // trying to use an arrow function using the this keyword 
    greet : () => console.log(`hey ${this.firstname}`)
}

jonas.calcAge()
// ---> 31
jonas.greet()
// ---> hey undefined

*** AN arrow function does not get a THIS 
keyword - the parent scope of the greet method 
is the global scope

this is an object litteral, not a code block - it does
not get its own scope

the arrow function ends up ising the window object of the browser
***Don't use an arrow function as a method

~~~~~~~~~~~~~~~~~~~~~~~
this keyword downfall - function inside of a method

const john = {
    name : 'john' ,
    birthyear : 1992 ,
    isMellenial : function() {
        console.log(this.birthyear > 1981 && this.birthyear < 1996)
    }
}

john.isMellenial()
---> true
~~~

const john = {
    firstname : 'john' ,
    year : 1992 ,
    calcAge : function() {
        const isMellenial = function() {
            console.log(this.birthyear > 1981 && this.birthyear < 1996)
        }
        isMellenial()
        //return 2022 - this.year
    } 
}

john.calcAge()

/* regular functions have this keyword as undefined 
solution 1. use const self = this (outside of the isMellenial function)
inside of the function you can use self.year etc. */

Now in es6 we have a more modern solution - use an arrow function
soultion 2. an arrow function does not have its own this keyword,
it will use the this keyword of its parent scope
const isMellenial = () => {
    console.log(this.year)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Arguments keyword

const addExpr = function (a,b) {
    console.log(arguments)
    return a + b
}

addExpr(2,5)
---> Arguments(2) [2, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ]

It is completely legal to add more arguments

addExpr(2, 4, 6, 8)
---> Arguments(4) [2, 4, 6, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]

~~~ arguments keyword with arrow function
var addArrow = (a,b) => {
    console.log(arguments)
    return a + b
}

addArrow(2,4,6,8)

!!!
---> arguments is not defined

*** the arguments keyword only exists in 
regular functions and not arrow functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Primitives vs. Objects (Primitive vs. Reference Types)


--- JS Primitive types ---
        Number
        String
        Boolean
        Undefined
        Null
        Symbol
        BigInt

Reference types
--- Objects ---
    Object literal
    Arrays
    Functions
    Many more

the way that data is stored in memory - reference types

--- JS engine ---


Call Stack : where functions are executed (primitives are stored in call stack)
Heap : where objects & reference types are stored in memory


const me = {
    name : 'andrew',
    age : 22,
}
const friend = me;
// creating an identical obj named friend

friend.age = 27;
console.log(friend.age)
console.log(me.age)

!!!
// both ages are now 27 even though the friend.age was changed
---> 27
---> 27

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const jessica = {
    firstname : 'jessica' ,
    lastname : 'williams' ,
    age : 27 ,
}

const jessicaCopy = Object.assign({}, jessica2);
// you can use this function to merge 2 objects and return a new one 

jessicaCopy.lastname = 'Davis'

console.log(jessica)
console.log(jessicaCopy)

---> {firstname: 'jessica', lastname: 'williams', age: 27}
---> {firstname: 'jessica', lastname: 'Davis', age: 27}

you can still preserve the property of the first while
creating a new value for the second

this method only works on the first level or if we have an obj
inside the obj then the inner obj will still point to the same place in memory 

this only creates a shallow copy , not a deep clone 
ex. if we had an array within the cloned obj, both would have the new arr, not just one 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Destructuring arrays (ES6) - a way of unpacking values from an array 
into separate variables - to break a complex data structure down 
into a variable

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
}

//how we would retrieve these three elements 
const arr = [2,3,4]
//const a = arr[0]
//const b = arr[1]
//const b = arr[2]

// with destructuring we can declare all three variables a the same time 
const [x,y,z] = arr
console.log(x,y,z)
---> 2 3 4

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Classes - blueprints for creating objects

class Student {

    constructor(name) {
        this.name=name;
    }

    displayName() {
        console.log(`this student's name is ${this.name}`)
    }

}

let studentOne = new Student('Andrew Brase');
studentOne.displayName()

let studentTwo = new Student('bob smith')
studentTwo.displayName()

--->    this student's name is Andrew Brase
--->    this student's name is bob smith
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class Person {

    constructor (name,age,height) {
        this.name = name
        this.age = age
        this.height = height
    }

    displayInfo() {
        console.log(`this persons name is ${this.name}, they are ${this.age} years old and they are ${this.height} tall`)
    }
}

let Tim = new Person ('Tim',25,'6ft')
let James = new Person ('James',44,'5ft')

Tim.displayInfo()
James.displayInfo()

--->    this persons name is Tim, they are 25 years old and they are 6ft tall
--->    this persons name is James, they are 44 years old and they are 5ft tall

//
console.log(Tim.age) ---> 25
console.log(James.age) ---> 44
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Inheritance

class Car {
    constructor(brand) {
        this.carname = brand
    }

    present() {
        return `I have a ${this.carname}`
    }
}

class Model extends Car {
    constructor( brand, mod ) {
        super(brand);
        this.model = mod
    }

    show() {
        console.log(this.present() + `, it is a ${this.model}`)
    }
}

mycar = new Model('Ford','Mustang')
mycar.show()
---> I have a Ford, it is a Mustang
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~