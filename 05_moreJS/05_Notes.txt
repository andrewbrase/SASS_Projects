this keyword/ variable : Special variable that is 
created for every execution context (every function).
Takes the value of (points to) the "owner" of the 
function in which the this keyword is used.

this is NOT static. It depends on how the function 
is called, and its value is only assigned when the 
function is actually called.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
different ways in which functions can be called
1. as a method - a function attached to an object
Method this = <object that is calling the method>

const andrew = {
    name : 'andrew' ,
    year : 2000 ,
    calcAge : function() {
        return 2022 - this.year;
    }
};

andrew.calcAge();
---> 22

2. simple function call -> this = undefined
this is only valid for strict mode - if not in strict mode,
this will point to the global object - window object

3. Arrow functions -> this = <this of surrounding function 
(lexical this) - it gets picked up by the outer lexical 
scope of the arrow function>

4. event listener -> this = <DOM element that the handler is attached to>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Method borrowing - taking one method from one obj and adding it to another obj

const dave = {
    name : 'dave' ,
    birthyear : 1965 ,
    calcAge : function () {
        return this.name + ' is ' + (2022 - this.birthyear)
    }
}

//dave.calcAge()
//~~~
 const matilda = {
    name : 'matilda' ,
    birthyear : 2005
 }

matilda.calcAge = dave.calcAge;
matilda.calcAge()

---> matilda is 17
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
regular functions vs arrow functions & this

const jonas = {
    firstname : 'jonas' ,
    year : 1991 ,
    calcAge : function() {
        return 2022 - this.year
    } ,

    // trying to use an arrow function using the this keyword 
    greet : () => console.log(`hey ${this.firstname}`)
}

jonas.calcAge()
// ---> 31
jonas.greet()
// ---> hey undefined

*** AN arrow function does not get a THIS 
keyword - the parent scope of the greet method 
is the global scope

this is an object litteral, not a code block - it does
not get its own scope

the arrow function ends up ising the window object of the browser
***Don't use an arrow function as a method

~~~~~~~~~~~~~~~~~~~~~~~
this keyword downfall - function inside of a method

const john = {
    name : 'john' ,
    birthyear : 1992 ,
    isMellenial : function() {
        console.log(this.birthyear > 1981 && this.birthyear < 1996)
    }
}

john.isMellenial()
---> true
~~~

const john = {
    firstname : 'john' ,
    year : 1992 ,
    calcAge : function() {
        const isMellenial = function() {
            console.log(this.birthyear > 1981 && this.birthyear < 1996)
        }
        isMellenial()
        //return 2022 - this.year
    } 
}

john.calcAge()

/* regular functions have this keyword as undefined 
solution 1. use const self = this (outside of the isMellenial function)
inside of the function you can use self.year etc. */

Now in es6 we have a more modern solution - use an arrow function
soultion 2. an arrow function does not have its own this keyword,
it will use the this keyword of its parent scope
const isMellenial = () => {
    console.log(this.year)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Arguments keyword

const addExpr = function (a,b) {
    console.log(arguments)
    return a + b
}

addExpr(2,5)
---> Arguments(2) [2, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ]

It is completely legal to add more arguments

addExpr(2, 4, 6, 8)
---> Arguments(4) [2, 4, 6, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]

~~~ arguments keyword with arrow function
var addArrow = (a,b) => {
    console.log(arguments)
    return a + b
}

addArrow(2,4,6,8)

!!!
---> arguments is not defined

*** the arguments keyword only exists in 
regular functions and not arrow functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Primitives vs. Objects (Primitive vs. Reference Types)


--- JS Primitive types ---
        Number
        String
        Boolean
        Undefined
        Null
        Symbol
        BigInt

Reference types
--- Objects ---
    Object literal
    Arrays
    Functions
    Many more

the way that data is stored in memory - reference types

--- JS engine ---


Call Stack : where functions are executed (primitives are stored in call stack)
Heap : where objects & reference types are stored in memory


const me = {
    name : 'andrew',
    age : 22,
}
const friend = me;
// creating an identical obj named friend

friend.age = 27;
console.log(friend.age)
console.log(me.age)

!!!
// both ages are now 27 even though the friend.age was changed
---> 27
---> 27

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const jessica = {
    firstname : 'jessica' ,
    lastname : 'williams' ,
    age : 27 ,
}

const jessicaCopy = Object.assign({}, jessica2);
// you can use this function to merge 2 objects and return a new one 

jessicaCopy.lastname = 'Davis'

console.log(jessica)
console.log(jessicaCopy)

---> {firstname: 'jessica', lastname: 'williams', age: 27}
---> {firstname: 'jessica', lastname: 'Davis', age: 27}

you can still preserve the property of the first while
creating a new value for the second

this method only works on the first level or if we have an obj
inside the obj then the inner obj will still point to the same place in memory 

this only creates a shallow copy , not a deep clone 
ex. if we had an array within the cloned obj, both would have the new arr, not just one 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Destructuring arrays (ES6) - a way of unpacking values from an array 
into separate variables - to break a complex data structure down 
into a variable

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
}

//how we would retrieve these three elements 
//const arr = [2,3,4]
//const a = arr[0]
//const b = arr[1]
//const b = arr[2]

// with destructuring we can declare all three variables a the same time 
//const [x,y,z] = arr
//console.log(x,y,z)
//---> 2 3 4

//const [first, second] = restaurant.catagories;
//console.log(first)
//console.log(second)

// ---> italian
// ---> pizzaria

// if you wanted to skip over the second element in the array 


let [first, ,third] = restaurant.catagories;

console.log(first, third)
console.log(third)

// ---> italian organic

[first, third] = [third, first]
console.log(first, third)

// ---> organic italian
~~~~~~~~~~~~~~~~~~~~~~~


const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    order : function(starterIndex, mainIndex) {
        return [this.startMenu[starterIndex], this.mainMenu[mainIndex]]
    }
}

// console.log(restaurant.order(2,0))
// ---> ['bread', 'pizza']

const [starter, main] = restaurant.order(2,0)
console.log(starter,main)

// ---> bread pizza

//nested destrucuring
const nested = [2,4,[5,6]]
const [i, ,[j,k]] = nested
console.log(i,j,k)
// ---> 2 5 6

//default values
const [p=1,q=1,r=1] = [8,9]
console.log(p,q,r)

// ---> 8 9 1 
~~~~~~~~~~~~~~~~~~~~~~~
Destructuring Objects 

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    openingHours: {
        thursday : {
            open : 5,
            close : 5,
        },
        friday : {
            open : 5,
            close : 4,
        },
        saturday : {
            open : 8,
            close : 12,
        },
    }
}

// to destructure obj use the curly braces
// the order desn't matter for this

// const {name, openingHours, catagories} = restaurant
// three new variables created from the restaurant obj

// console.log(name)
// console.log(openingHours)
// console.log(catagories)

// --->

// string ---> classico italiano
// obj ---> {thursday: {…}, friday: {…}, saturday: {…}}
// arr ---> ['italian', 'pizzaria', 'organic']

// you can rename the variables destructured
const {name: restaurantName, openingHours: hours, catagories: tags} = restaurant
console.log(restaurantName)
console.log(hours)
console.log(tags)

// string ---> classico italiano
// obj ---> {thursday: {…}, friday: {…}, saturday: {…}}
// arr ---> ['italian', 'pizzaria', 'organic']

// mutating variables
let a = 111
let b = 999

const obj = {a : 23, b : 7, c : 14}

// need ()
({a,b} = obj)
console.log(a,b)

~~~~~~~~~~~
let a = 111;
let b = 999;
const obj = { a: 23, b: 7, c: 14};
({a, b} = obj);
console.log(a, b);

---> 23 7

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    openingHours: {
        thursday : {
            open : 5,
            close : 5,
        },
        friday : {
            open : 5,
            close : 4,
        },
        saturday : {
            open : 8,
            close : 12,
        },
    }
}

// netsed object destructuring
//const {friday, saturday} = restaurant.openingHours
//console.log(friday)
//console.log(saturday)

//--->
//(fri) {open: 5, close: 4}
//(sat) {open: 8, close: 12}

const {friday: {open: o, close: c}, saturday: {open : so, close: sc} } = restaurant.openingHours;
console.log(o,c)
console.log(so,sc)

---> 5 4
---> 8 12
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    openingHours: {
        thursday : {
            open : 5,
            close : 5,
        },
        friday : {
            open : 5,
            close : 4,
        },
        saturday : {
            open : 8,
            close : 12,
        },
    },

    orderDelivery: function({ starterIndex, mainIndex, deliverytime, address}) {
        console.log(`order recieved : ${this.startMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be deliverd to ${address} at time ${deliverytime}`)
    },
}

// passing in an obj into a method of another obj
// you can do destructuring right away
// calling a method with an object

restaurant.orderDelivery ({
    deliverytime : '10pm',
    address : 'via del sole ,21',
    mainIndex: 2,
    starterIndex: 2,
})

--->
---> order recieved : bread and risotto will be deliverd to via del sole ,21 at time 10pm

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Spread Operator (...)
can unpack all array elements at once

const arr = [7, 8, 9];

const newarr = [1 , 2, ...arr];
console.log(newarr)

---> [1, 2, 7, 8, 9]

console.log(...newarr)
---> 1 2 7 8 9

// whenever you need the individual elements of an array use the spread operator

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , 'bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
}

// we are creating a new arr, NOT mainipulating the existing arr
// you could mainipulate the arr by using the push() method

//const newMenu = [...restaurant.mainMenu, 'Gnocci'];
//console.log(newMenu)

//---> ['pizza', 'pasta', 'risotto', 'Gnocci']
// copy array

//const mainMenuCopy = [...restaurant.mainMenu];

// join 2 arrays or more
const menu = [...restaurant.mainMenu, ...restaurant.startMenu]
console.log(menu)

// ---> ['pizza', 'pasta', 'risotto', 'focaccia', 'bruschetta', 'bread']

// the spread operator works on all iterables 
// that means arrays, strings, maps, sets

const name = 'andrew'
const letters = [...name]
console.log(letters)
// --->  ['a', 'n', 'd', 'r', 'e', 'w']
~~~~~~~~~~~~~~~~~~~~~~~

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , 'bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    orderPasta : function(ingredient1 , ingredient2, ingredient3) {
        console.log(`here\'s your pasta with ${ingredient1}, ${ingredient2}, ${ingredient3}`)
    }
}

const ingredientsArr = ['olives','shrimp','cheese']

// using the order pasta method in restaurant obj
// using the spread operator to pass in all items in the array to the arguments of the method

restaurant.orderPasta(...ingredientsArr)

// ---> here's your pasta with olives, shrimp, cheese

~~~~~~~~~~~~~~~~~~~~~~~
// you can use the spread operator on objects to create new objects 

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , 'bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
}

const newRest = {...restaurant, founder: 'Andrew'}
console.log(newRest.mainMenu[1], newRest.founder)

// ---> pasta, Andrew
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Rest Pattern and Parameters

will collect multiple elements and condense them into the same array
opposite of spread operator

// RECAP of spread, the dots are on the Right side of the = sign
const arr = [1,2,...[3,4]]

// destructuring you can use REST operator syntax
// LEFT side of the = sign
const [a,b, ...others] = [1,2,3,4,5]
console.log(a)
console.log(b)
console.log(others)

---> 1
---> 2
---> [3, 4, 5]


*** REST - instructs the computer to add whatever otherInfo (arguments) supplied by the user into an array
*** Spread - takes in an iterable (e.g an array) and expands it into individual elements


Rest will take the rest of the elements of an arr and assign them to a new arr - used with destructuring
const [a,b, ...others] = [1,2,3,4,5]

const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
}

// using SPREAD and REST 
// destructuring the main menu and startmenu using spread into variables pizza, pasta and using the REST operator to assign everything else to an arr
// spread is used to assign everything from this array to a variable
// rest is used to assign everything else in the array to a variable

const [pizza, pasta, ...otherfood ] = [...restaurant.mainMenu, ...restaurant.startMenu]

console.log(pizza, pasta)
console.log(otherfood)

---> pizza pasta
---> ['risotto', 'focaccia', 'bruschetta', 'bread']

// This also works with objects as well

// Objects 

// created a restaurant obj with another obj named openingHours
const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
    openingHours : {
        thursday : {
            open : '5am',
            close : '5pm',
        },
        friday : {
            open : '5am',
            close : '3pm',
        },
        saturday : {
            open : '8am',
            close : '8pm',
        },
    },
}

// deconstructing restaurant.openingHours into saturday and also weekdays using the rest pattern
const {saturday, ...weekdays} = restaurant.openingHours

console.log(saturday.close)
console.log(weekdays.thursday.close)
console.log(weekdays.friday.close)

// ---> 
// 8pm
// 5pm
// 3pm

// for the spread operator, another use case was to pass multiple arguments into function all at the same time

// use of rest operator to pack everything into one array 
const add = function(...numbers) {
    let sum = 0;
    for (let i = 0; i < numbers.length; i++) {
        sum += numbers[i]
    }

    console.log(sum)
}

let arr = [3,4,5,6,7,8,9]

// use of spread operator
add(1,2, ...arr)

---> 45

ex. orderPizza : function( mainIngredient, ...otherIngredients) {
}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Classes - blueprints for creating objects

class Student {

    constructor(name) {
        this.name=name;
    }

    displayName() {
        console.log(`this student's name is ${this.name}`)
    }

}

let studentOne = new Student('Andrew Brase');
studentOne.displayName()

let studentTwo = new Student('bob smith')
studentTwo.displayName()

--->    this student's name is Andrew Brase
--->    this student's name is bob smith
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class Person {

    constructor (name,age,height) {
        this.name = name
        this.age = age
        this.height = height
    }

    displayInfo() {
        console.log(`this persons name is ${this.name}, they are ${this.age} years old and they are ${this.height} tall`)
    }
}

let Tim = new Person ('Tim',25,'6ft')
let James = new Person ('James',44,'5ft')

Tim.displayInfo()
James.displayInfo()

--->    this persons name is Tim, they are 25 years old and they are 6ft tall
--->    this persons name is James, they are 44 years old and they are 5ft tall

//
console.log(Tim.age) ---> 25
console.log(James.age) ---> 44

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Inheritance

class Car {
    constructor(brand) {
        this.carname = brand
    }

    present() {
        return `I have a ${this.carname}`
    }
}

class Model extends Car {
    constructor( brand, mod ) {
        super(brand);
        this.model = mod
    }

    show() {
        console.log(this.present() + `, it is a ${this.model}`)
    }
}

mycar = new Model('Ford','Mustang')
mycar.show()
---> I have a Ford, it is a Mustang
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Short Circuiting (&& and ||)

// and & or operators can return any data type, not just boolean

/* in the case of the or operator short circuiting means that if 
the first value is a truthy value it will immediately return the first value */

console.log(3 || 'andrew')
// ---> 3

console.log(false || 'andrew')
// ---> 'andrew'

console.log('' || 'andrew')
// ---> 'andrew'

console.log(0 || true)
// ---> true

console.log(undefined || null)
// ---> null

~~~
Turnery Operator
const restaurant = {}
const guests = restaurant.numGuests ? restaurant.numGuests : 10;
console.log(guests)

// restaurant.numGuests is undefined
// ---> 10

const result = 10 % 2 === 0 ? 'that is true' : 'that is false'
console.log(result)

// ---> 'that is true'

const newresult = 5 * 5 === 0 ? 0 : 25;
console.log(newresult)

// ---> 25

// so instead of doing this we can take advantage of short circuiting and the OR operator
const restaurant = {}
const guests = restaurant.numGuests || 10
console.log(guests)
// ---> 10

~~~~~~~~~~~~~~~~~~~~~~~
// the && operator will return the first falsy value

console.log(0 && 'andrew')
// ---> 0

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Nullish coalescing operator (??)

// returns its right-hand side operand when its left-hand side operand is 
// null or undefined

const result = null ?? 'andrew'
console.log(result)

// ---> 'andrew'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Logical Assignment Operators

const rest1 = {
    name : 'Capri',
    numGuest : 20,
}

const rest2 = {
    name : 'La Piazza',
    owner : 'Giovanni Rossi',
}

// ~~~~~~~~~~~~~~~~~~~~~~~~
// The OR assignment operator
// this operator assigns a value to a variable if that variable is currently falsy 

// rest1.numGuest = rest1.numGuest || 10
// ---> 20

// numGuest is not in rest 2 obj making it falsy
// rest2.numGuest = rest2.numGuest || 10
// ---> 10

// This can be written as 

rest1.numGuest ||= 10
// ---> 20

rest2.numGuest ||= 10
// ---> 10

console.log(rest1)
console.log(rest2)

{name: 'Capri', numGuest: 20}

//                                               !!!
{name: 'La Piazza', owner: 'Giovanni Rossi', numGuest: 10}

~~~~~~~~~~~~~~~~~~~~~~~~
The Nullish Assignment Operator (nullish means null or undefined)
// assign a value to a variable if that variable is currently nullish

rest1 = {
    numGuest : 0
}

rest2 = {
    name : 'andrew'
}

rest1.numGuest ??= 10;
rest2.numGuest ??= 10;

console.log(rest1)
console.log(rest2)

// --->
{numGuest: 0}
{name: 'andrew', numGuest: 10}


~~~~~~~~~~~~~~~~~~~~~~~~
The AND assignment Operator
// is there currently is an owner, you could anonymize the name
//  assign a value to a variable if it is currently truthy (it exists)

rest1 = {
    ownerName : 'andrew'
}

rest2 = {
    food : 'pasta'
}

// rest1.ownerName &&= 'anon'
// console.log(rest1)
// ---> {ownerName: 'anon'}

rest2.ownerName &&= 'anon'
// ---> undefined
// (there is no ownerName in rest2)
console.log(rest2)
// ---> {food: 'pasta'}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Looping Arrays: The for-of Loop

const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
}

const menu = [...restaurant.mainMenu , ...restaurant.startMenu]

//for (const food of menu) console.log(food)

// --->
//pizza
//pasta
//risotto
//focaccia
//bruschetta
//bread

// this method not as good getting the index

//for (const item of menu.entries()) {
    //console.log(item)
    // this will make every element an array with the [index, value]
//}

// --->
// [0, 'pizza']
// [1, 'pasta']
// [2, 'risotto']
// [3, 'focaccia']
// [4, 'bruschetta']
// [5, 'bread']

for (const item of menu.entries()) {
    console.log(item[0])
    // this will make every element an array with the [index, value]
}

// --->
// 0
// 1
// 2
// 3
// 4
// 5


// we can use destructuring to make this easier

const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
}

const menu = [...restaurant.mainMenu , ...restaurant.startMenu]

for (const [index, element] of menu.entries()) {
    console.log(`${index} : index , ${element} : element`)
}

// --->
0 : index , pizza : element
1 : index , pasta : element
2 : index , risotto : element
3 : index , focaccia : element
4 : index , bruschetta : element
5 : index , bread : element
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Optional Chaining (.?)
// feature of objects and arrays

const restaurant = {
    openingHours : {
        // missing Monday
        tue : {
            open : '5am',
            close : '5pm',
        },
        wed : {
            open : '5am',
            close : '5pm',
        },
        thu : {
            open : '5am',
            close : '5pm',
        },
        fri : {
            open : '5am',
            close : '3pm',
        },
        sat : {
            open : '5am',
            close : '10pm',
        },
        sun : {
            open : '5am',
            close : '10pm',
        },
    },
};
console.log(restaurant.openingHours?.tue?.open)

console.log(restaurant.openingHours.mon.open)
// ---> Cannot read properties of undefined

// this is just checking for ONE property Monday
if (restaurant.openingHours.mon) console.log(restaurant.openingHours.mon.open)

// with Optional chaining, if a certain property does not exist, 
// then undefined is returned immediately 

// WITH optional chaining 
// only if monday? exists then the open property will be read, if not undefined will be returned

console.log(restaurant.openingHours.mon?.open)
// ---> undefined

we can do the same for opening hours
console.log(restaurant.openingHours?.tue?.open)
// ---> 5am

~~~~~~~~~~~~~~~~~~~~~~~~
// going to loop through an array of days to see if the restaurant is open
const days = ['mon','tue','wed','thu','fri','sat','sun'];

for (const day of days) {
    const isOpen = restaurant.openingHours[day]?.open || 'closed'
    console.log(`on ${day}, we open at : ${isOpen}`)
}

// --->
on mon, we open at : closed
on tue, we open at : 5am
on wed, we open at : 5am
on thu, we open at : 5am
on fri, we open at : 5am
on sat, we open at : 5am
on sun, we open at : 5am

// the problem with this is that 0 is a falsy value -  if open was set to 0
// so it will trigger the second part of the operator
// - the solution is to use the nullish coalescing operator

    const isOpen = restaurant.openingHours[day]?.open ?? 'closed'

~~~~~~~~~~~~~~~~~~~~~~~~
Optional Chaining on Methods
// we can check if a method exists before calling it

const restaurant = {
    order : function(a,b) {
        console.log(a+b)
    }
}

console.log(restaurant.order?.(1,2) ?? 'Method does not exist')

const users = [{ name: 'andrew', email : 'andrewbrase1'}]
console.log(users[0]?.name ?? 'user array empty')
// ---> andrew 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Looping Objects: Object Keys, Values, and Entries

const restaurant = {

    openingHours : {
        mon : {
            open : '5am',
            close : '5pm',
        },
        tue : {
            open : '5am',
            close : '5pm',
        },
        wed : {
            open : '5am',
            close : '5pm',
        },
        thu : {
            open : '5am',
            close : '5pm',
        },
        fri : {
            open : '5am',
            close : '3pm',
        },
        sat : {
            open : '5am',
            close : '10pm',
        },
        sun : {
            open : '5am',
            close : '10pm',
        }
    }
}

//for (const day of Object.keys(restaurant.openingHours)) {
//    console.log(day)
//}

// --->
//mon
//tue
//wed
//thu
//fri
//sat
//sun

const properties = Object.keys(restaurant.openingHours)
console.log(properties)
// ---> ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']

let openStr = `We are open on ${properties.length} days: `
for (const day of properties) {
    openStr += `${day}, `
}

// ---> 'We are open on 7 days: mon, tue, wed, thu, fri, sat, sun, '

// property values
const values = Object.values(restaurant.openingHours)
console.log(values)

// --->
0: {open: '5am', close: '5pm'}
1: {open: '5am', close: '5pm'}
2: {open: '5am', close: '5pm'}
3: {open: '5am', close: '5pm'}
4: {open: '5am', close: '3pm'}
5: {open: '5am', close: '10pm'}
6: {open: '5am', close: '10pm'}
length: 7

// entries are names plus the values together
const entries = Object.entries(restaurant.openingHours)
console.log(entries)

// --->
// 0: "mon"
// 1: {open: '5am', close: '5pm'}
// (etc.)

//we can use destructuring to define these open close times as well as the day
for (const [key , {open, close}] of entries) {
    console.log(`on ${key} we open at ${open} and close at ${close}`)
}

// --->
on mon we open at 5am and close at 5pm
on tue we open at 5am and close at 5pm
on wed we open at 5am and close at 5pm
on thu we open at 5am and close at 5pm
on fri we open at 5am and close at 3pm
on sat we open at 5am and close at 10pm
on sun we open at 5am and close at 10pm

~~~ All together ~~~

const restaurant = {
    openingHours : {
        mon : {
            open : '5am',
            close : '5pm',
        },
        tue : {
            open : '5am',
            close : '5pm',
        },
        wed : {
            open : '5am',
            close : '5pm',
        },
    },
};

const entries = Object.entries(restaurant.openingHours)
for (const [key , {open, close}] of entries) {
    console.log(`on ${key} we open at ${open} and close at ${close}`)
}

// --->
on mon we open at 5am and close at 5pm
on tue we open at 5am and close at 5pm
on wed we open at 5am and close at 5pm

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const iceCream = {
    flavors : {
        mint : {
            status : 'out of stock'
        },
        strawberry : {
            status : 'available'
        },
        chocolate : {
            status : 'almost gone'
        },
    },
};

const iceCreamEntries = Object.entries(iceCream.flavors)
for (const [flavor, {status}] of iceCreamEntries){
    console.log(`the flavor ${flavor} is ${status}`)
}

// --->
the flavor mint is out of stock
the flavor strawberry is available
the flavor chocolate is almost gone

for (const flavor of Object.keys(iceCream.flavors)){
    console.log(flavor)
}

// --->
mint
strawberry
chocolate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sets 

const arr = ['andrew','andrew','bob','dave','andrew','dave']
const set = new Set(arr)
// console.log(set)
// --->
// {'andrew', 'bob', 'dave'}

console.log(set.size)
// sets use size not length
// ---> 3

// sets can use the HAS method to see if they are included in that set 
console.log(set.has('andrew'))
// ---> true 

// the ADD method
set.add('steve')
// --->
{'andrew', 'bob', 'dave', 'steve'}

//.delete('bob')

//.clear()

const staff = ['waiter','chef','waiter','waiter','manager']
// const staffUnique = new Set(staff)
// console.log(staffUnique)
// --->
// {'waiter', 'chef', 'manager'}

const staffUnique = [...new Set(staff)]
console.log(staffUnique)

// creates an array of all of the set elements
// ---> ['waiter', 'chef', 'manager']

new Set(['waiter','chef','waiter','waiter','manager']).size
// ---> 3

console.log(new Set('andrewbrase').size);
// ---> 8
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Maps Fundamentals
// the keys do not need to be strings 

const rest = new Map();

//use the set method, pass in two arguments - the first will be the keyname
// rest.set('name','Classico Italiano');
// rest.set(1, 'Italy');
// rest.set(2, 'Lisbon');

rest
    .set('catagories', ['italian','pizzaria','organic'])
    .set('open',11)
    .set('close',5);

{"catagories" => 
1: {"open" => 11}
2: {"close" => 5}

// the keys do not need to be strings 

const rest = new Map();

rest
    .set('catagories', ['italian','pizzaria','organic'])
    .set('open',11)
    .set('close',23)
    .set(true, 'we are open')
    .set(false, 'we are closed')
    .set(1, 'Italy')
    .set(2, 'Lisbon')

// to read data from a map we can use the get method

// console.log(rest.get(true))

// ---> 
// we are open

// const time = 23;
// console.log(rest.get(time > rest.get('open') && time < rest.get('close')))
// ---> we are closed

// we can check if a map has a certain key with the HAS method
// console.log(rest.has('Halloween'))
// ---> false
// console.log(rest.has('catagories')
// ---> true

// get rid of Lisbon
// rest.delete(2)
// console.log(rest)

// ---> 
// {"catagories" => Array(3)}
// 1: {"open" => 11}
// 2: {"close" => 23}
// 3: {true => "we are open"}
// 4: {false => "we are closed"}
// 5: {1 => "Italy"}

// maps can also use size
console.log(rest.size)
// ---> 7

// maps can also use clear
rest.clear()

// for setting an array as a key

const rest = new Map();
const arr = [1,2]
rest.set(arr, 'test')
console.log(rest.get(arr))

// ---> test

// you can also integrate DOM elements into the Map object

rest.set(document.querySelector('h1'), 'Heading');
// key: h1
// value: 'Heading'

// set can be combersome if there are a lot of values to add to the Map
// there will be arrays with the first value being the key
const quiz = new Map([
    ['question','what is the best programming language'],
    [1, 'C language'],
    [2, 'Java'],
    [3, 'Javascript'],
    ['correct', 3],

    // when the user is correct
    [true , 'correct'],
    [false , 'try again'],
])

console.log(quiz)

// ---> 
{"question" => "what is the best programming language"}
key: "question"
value: "what is the best programming language"

{1 => "C language"}
2: {2 => "Java"}
3: {3 => "Javascript"}
4: {"correct" => 3}
5: {true => "correct"}
6: {false => "try again"}

~~~~~~~~~~~~~~~~~~
// converting objects to Map

const iceCream = {
    flavors : {
        mint : {
            status : 'out of stock'
        },
        strawberry : {
            status : 'available'
        },
        chocolate : {
            status : 'almost gone'
        },
    },
};

// console.log(Object.entries(iceCream.flavors))
const iceCreamMap = new Map(Object.entries(iceCream.flavors))

console.log(iceCreamMap)
//~~~~~~~~~~~~~~~~~~
//Iteration on Maps
// the for loop is available for use

const quiz = new Map([
    ['question','what is the best programming language?'],
    [1, 'C'],
    [2, 'Java'],
    [3, 'Javascript'],
    ['correct', 3],

    // when the user is correct
    [true , 'correct'],
    [false , 'try again'],
])

// the for loop is available for use
console.log(quiz.get('question'))
for (const [key, value] of quiz){
    if( typeof key === 'number') console.log(`Answer ${key} : ${value}`)
}

const answer = prompt('Your answer')

quiz.get(quiz.get('correct') === answer)
// this will return true or false which we can use in the Map

// ---> 
what is the best programming language?
Answer 1 : C
Answer 2 : Java
Answer 3 : Javascript

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Working with strings
// Javascript String is immutable, you'd have to create a new variable

string.slice(1, 8) // starts at index 1 - ends at 8
string.toUpperCase()
string.toLowerCase()
string.trim()
string.replace('a','b')
string.replaceAll()

// use regular expression to tell the replace method to target all occurrences of 'door'
console.log(string.replace( /door/g , 'gate' ))

const plane = 'A230n'
// console.log(plane.includes('A230'))
// ---> true

console.log(plane.startsWith('A'))
// ---> true

const newPlane = 'Airbus A320neo'
if ( newPlane.startsWith('Airbus') && newPlane.endsWith('neo')) {
    // if true , true
    console.log('this is an airbus neo')
}

const checkBaggage = function(items){
    const baggage = items.toLowerCase()
    if (baggage.includes('knife')) {
        console.log('not allowed on flight')
    } else {
        console.log('welcome aboard')
    }
}

checkBaggage('I have a laptop, some food and a pocket knife')

// ---> not allowed on flight

const str = 'this+string'
console.log(str.split('+').join(' '))
// ---> this string

const [firstname, lastname] = 'Andrew Brase'.split(' ')
console.log(firstname)
// ---> Andrew

// add padding to a string
const str = 'Andrew'
console.log(str.padStart(20, ' '))
// --->               Andrew
// will make the string 20 characters long

const maskCreditCard = function(number) {
    // converts to string
    const str = number + '';
    const last = str.slice(-4)
    console.log(last.padStart(str.length, '*'))

}

maskCreditCard(121234234231423)

// ---> 
***********1423

// repeat method
// repeat the same string multiple times

const rep = 'repeat'

console.log(rep.repeat(5))

// ---> 
repeatrepeatrepeatrepeatrepeat
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Default Parameters

'use strict';

const bookings = []

const createBooking = function ( flightNum, numPassengers, price ) {
    const bookingInfo = {
        flightNum,
        numPassengers,
        price,
    }

    console.log(bookingInfo)
    bookings.push(bookingInfo)
}

createBooking('LH132')

// ---> 
{flightNum: 'LH132', 
numPassengers: undefined, 
price: undefined}

~~~~~~~~~~~~~~~~~~~~~~~
*** OLD way of defining default parameters

const createBooking = function ( flightNum, numPassengers, price ) {

    //es5
    //*** using short circuiting
    //numPassengers = numPassengers || 1;
    //price = price || 199;

    const bookingInfo = {
        flightNum,
        numPassengers,
        price,
    }

    console.log(bookingInfo)
    bookings.push(bookingInfo)
}

You could do this instead

const createBooking = function ( flightNum =1, numPassengers = 1, price =1) {

~~~~~~~~~~~~~~~~~~~~~~~
const bookings = []

const createBooking = function ( 
    flightNum = 1 , 
    numPassengers = 1, 
    price = 199 + numPassengers) {
    const bookingInfo = {
        flightNum,
        numPassengers,
        price,
    }

    console.log(bookingInfo)
    bookings.push(bookingInfo)
}

createBooking('LH132',33)

// ---> {flightNum: 'LH132', numPassengers: 33, price: 232}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
How Passing Arguments Works: Value vs. Reference

const flight = 'LH234'
const andrew = {
    name : 'andrew',
    passport : 345298342,
}

const checkIn = function(flightNum, passenger) {
    // flight has changed
    flightNum = 'LH553';
    passenger.name = 'Mr.' + passenger.name;

    if (passenger.passport === 345298342) {
        console.log('check in')
    } else {
        console.log('wrong passport number')
    }
}

checkIn(flight, andrew);
console.log(flight)
console.log(andrew)

/* 
 the primitive type was not chaged however 
 the object/ reference type was ('Mr.andrew')
 the flight number is a copy of the flight value
 flightNum = flight
 wehen we pass a refernce type into a function
 what is copied is the reference to thte copy in the memory heap
 passenger = andrew 
*/

// ---> 
check in
LH234
{name: 'Mr.andrew', passport: 345298342}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
First-Class and Higher-Order functions

/* 
javascript treats functions as values 
functions are just another "type" of object

since functions are values, 
* we can store them in variables or object properties

ex. const add = (a, b) => a + b;
ex. const counter = {
    value : 23,
    inc : function() {
        this.value++;
    }
}

~~~~~~~~~~~~~~~~~~~~~~~
* we can also pass functions as arguments

const greet = () = > console.log('hello andrew');
btnClose.addEventListener('click', greet)

* we can also return functions from functions

* there are methods that we can use on functions
counter.inc.bind(someOtherObject);
* the BIND method

*/
/*
~~~~~~~~~~~~~~~~~~~~~~~
Higher Order Functions
* A function that recievs another function as 
an argument, that returns a new function, or both

const greet = () = > console.log('hello andrew');
btnClose.addEventListener('click', greet)

(accepting a function as an input & Callback Function)
1.)
* addEventListener is a higher order function that accepts the greet arg/function
* the function passed is is usually a callback function becuase
it is waiting for the click event to happen to call the greet
- do not greet until click

2.)
(Function that returns a new fnction)

(Higher Order Function)
function count() {
    let counter = 0;
    return function() {
        counter ++;
    };
}

* FIRST CLASS functions is just a feature that a programming
language has/doesn't have - All Functions are Values

* HIGHER ORDER FUNCTIONS
*/

const oneWord = function(str) {
    return str.replace(/ /g, '').toLowerCase();
}
// oneWord('Andrew M Brase')
// ---> andrewmbrase

const upperFirstWord = function(str) {
    const [firstWord, ...otherWords] = str.split(' ');
    return [firstWord.toUpperCase(), ...otherWords].join(' ')
}

// we can create our Higher Order Function with these two generic functions
const transformer = function (str,func) {
    console.log(func(str))
}

transformer('learning javascript is fun', upperFirstWord)
// ---> LEARNING javascript is fun

// upperFirstWord would be the callback function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Functions Returning Functions

const greet = function(greeting) {
    return function(name) {
        console.log(`${greeting} ${name}`);
    }
}

//const greetHey = greet('Hey');

//greetHey('andrew');
// ---> Hey andrew

// this works becuase it is a closure

//greet('hello')('Andrew')
// ---> hello Andrew

/* functions returning other functions can be useful in
some situations especially with functional programming*/

// we dont need the {} or return with the arrow function one line
const greetArr = greeting => name => console.log(`${greeting} ${name}`)

greetArr('hi')('andy')
// ---> hi andy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The call and apply Methods

~~~~~~~~~~~~~~~~~~~~~~~~
The Call Method

const luft = {
    airline : 'Luft',
    code : 'LH',
    bookings : [],
    book(flightNum, passengerName) {
        console.log(`${passengerName} booked a seat on ${this.airline}${this.code} flight number ${flightNum}`)

        this.bookings.push({ flight: `${flightNum}${this.code}`, passengerName })
    }
}

//luft.book(122,'Andrew')
//console.log(luft)

// ---> 
//Andrew booked a seat on LuftLH flight number 122

// ---> 
//bookings: 
//0: {flight: '122LH', passengerName: 'Andrew'}

const eurowings = {
    airline : 'Euro',
    code : 'EW',
    bookings : [],   
}

/* instead of copying the method from the first obj,
we can store it in an external function and reuse 
that function for any other objects */

const bookFlight = luft.book;

/* if we want to book a luft flight the this keyword should point to luft
if we want to book a euro flight the this keyword should point to euro
there are 3 function methods to do that,
they are Call, Apply and Bind */

//bookFlight.call(eurowings, 443, 'Dan')
//console.log(eurowings.bookings[0])

/* ---> 
{flight: '443EW', passengerName: 'Dan'}
*/

bookFlight.call(luft, 239, 'Steven')
// ---> 
//Steven booked a seat on LuftLH flight number 239
// the this keyword has been set to luft

/* you can have seperate objects that can reuse the same method
you can manipulate the this keyword with the call method
you must have the same property names */

//~~~~~~~~~~~~~~~~~~~~~~~
//The Apply Method
/* apply does close to what call does except,
Apply does not recieve a list of arguments after the
this keyword, but instead its going to take an array of elements 
and pass it into the function
*/

// passing the flightData array into the second arg
const flightData = [544, 'Fred'];
bookFlight.apply(eurowings, flightData);

// ---> 
Fred booked a seat on EuroEW flight number 544

// instead of using apply we can use call and then we can use
the spread operator instead

// !!! this is the same result
bookFlight.call( eurowings, ...flightData )