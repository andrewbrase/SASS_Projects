this keyword/ variable : Special variable that is 
created for every execution context (every function).
Takes the value of (points to) the "owner" of the 
function in which the this keyword is used.

this is NOT static. It depends on how the function 
is called, and its value is only assigned when the 
function is actually called.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
different ways in which functions can be called
1. as a method - a function attached to an object
Method this = <object that is calling the method>

const andrew = {
    name : 'andrew' ,
    year : 2000 ,
    calcAge : function() {
        return 2022 - this.year;
    }
};

andrew.calcAge();
---> 22

2. simple function call -> this = undefined
this is only valid for strict mode - if not in strict mode,
this will point to the global object - window object

3. Arrow functions -> this = <this of surrounding function 
(lexical this) - it gets picked up by the outer lexical 
scope of the arrow function>

4. event listener -> this = <DOM element that the handler is attached to>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Method borrowing - taking one method from one obj and adding it to another obj

const dave = {
    name : 'dave' ,
    birthyear : 1965 ,
    calcAge : function () {
        return this.name + ' is ' + (2022 - this.birthyear)
    }
}

//dave.calcAge()
//~~~
 const matilda = {
    name : 'matilda' ,
    birthyear : 2005
 }

matilda.calcAge = dave.calcAge;
matilda.calcAge()

---> matilda is 17
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
regular functions vs arrow functions & this

const jonas = {
    firstname : 'jonas' ,
    year : 1991 ,
    calcAge : function() {
        return 2022 - this.year
    } ,

    // trying to use an arrow function using the this keyword 
    greet : () => console.log(`hey ${this.firstname}`)
}

jonas.calcAge()
// ---> 31
jonas.greet()
// ---> hey undefined

*** AN arrow function does not get a THIS 
keyword - the parent scope of the greet method 
is the global scope

this is an object litteral, not a code block - it does
not get its own scope

the arrow function ends up ising the window object of the browser
***Don't use an arrow function as a method

~~~~~~~~~~~~~~~~~~~~~~~
this keyword downfall - function inside of a method

const john = {
    name : 'john' ,
    birthyear : 1992 ,
    isMellenial : function() {
        console.log(this.birthyear > 1981 && this.birthyear < 1996)
    }
}

john.isMellenial()
---> true
~~~

const john = {
    firstname : 'john' ,
    year : 1992 ,
    calcAge : function() {
        const isMellenial = function() {
            console.log(this.birthyear > 1981 && this.birthyear < 1996)
        }
        isMellenial()
        //return 2022 - this.year
    } 
}

john.calcAge()

/* regular functions have this keyword as undefined 
solution 1. use const self = this (outside of the isMellenial function)
inside of the function you can use self.year etc. */

Now in es6 we have a more modern solution - use an arrow function
soultion 2. an arrow function does not have its own this keyword,
it will use the this keyword of its parent scope
const isMellenial = () => {
    console.log(this.year)
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Arguments keyword

const addExpr = function (a,b) {
    console.log(arguments)
    return a + b
}

addExpr(2,5)
---> Arguments(2) [2, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ]

It is completely legal to add more arguments

addExpr(2, 4, 6, 8)
---> Arguments(4) [2, 4, 6, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]

~~~ arguments keyword with arrow function
var addArrow = (a,b) => {
    console.log(arguments)
    return a + b
}

addArrow(2,4,6,8)

!!!
---> arguments is not defined

*** the arguments keyword only exists in 
regular functions and not arrow functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Primitives vs. Objects (Primitive vs. Reference Types)


--- JS Primitive types ---
        Number
        String
        Boolean
        Undefined
        Null
        Symbol
        BigInt

Reference types
--- Objects ---
    Object literal
    Arrays
    Functions
    Many more

the way that data is stored in memory - reference types

--- JS engine ---


Call Stack : where functions are executed (primitives are stored in call stack)
Heap : where objects & reference types are stored in memory


const me = {
    name : 'andrew',
    age : 22,
}
const friend = me;
// creating an identical obj named friend

friend.age = 27;
console.log(friend.age)
console.log(me.age)

!!!
// both ages are now 27 even though the friend.age was changed
---> 27
---> 27

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const jessica = {
    firstname : 'jessica' ,
    lastname : 'williams' ,
    age : 27 ,
}

const jessicaCopy = Object.assign({}, jessica2);
// you can use this function to merge 2 objects and return a new one 

jessicaCopy.lastname = 'Davis'

console.log(jessica)
console.log(jessicaCopy)

---> {firstname: 'jessica', lastname: 'williams', age: 27}
---> {firstname: 'jessica', lastname: 'Davis', age: 27}

you can still preserve the property of the first while
creating a new value for the second

this method only works on the first level or if we have an obj
inside the obj then the inner obj will still point to the same place in memory 

this only creates a shallow copy , not a deep clone 
ex. if we had an array within the cloned obj, both would have the new arr, not just one 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Destructuring arrays (ES6) - a way of unpacking values from an array 
into separate variables - to break a complex data structure down 
into a variable

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
}

//how we would retrieve these three elements 
//const arr = [2,3,4]
//const a = arr[0]
//const b = arr[1]
//const b = arr[2]

// with destructuring we can declare all three variables a the same time 
//const [x,y,z] = arr
//console.log(x,y,z)
//---> 2 3 4

//const [first, second] = restaurant.catagories;
//console.log(first)
//console.log(second)

// ---> italian
// ---> pizzaria

// if you wanted to skip over the second element in the array 


let [first, ,third] = restaurant.catagories;

console.log(first, third)
console.log(third)

// ---> italian organic

[first, third] = [third, first]
console.log(first, third)

// ---> organic italian
~~~~~~~~~~~~~~~~~~~~~~~


const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    order : function(starterIndex, mainIndex) {
        return [this.startMenu[starterIndex], this.mainMenu[mainIndex]]
    }
}

// console.log(restaurant.order(2,0))
// ---> ['bread', 'pizza']

const [starter, main] = restaurant.order(2,0)
console.log(starter,main)

// ---> bread pizza

//nested destrucuring
const nested = [2,4,[5,6]]
const [i, ,[j,k]] = nested
console.log(i,j,k)
// ---> 2 5 6

//default values
const [p=1,q=1,r=1] = [8,9]
console.log(p,q,r)

// ---> 8 9 1 
~~~~~~~~~~~~~~~~~~~~~~~
Destructuring Objects 

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    openingHours: {
        thursday : {
            open : 5,
            close : 5,
        },
        friday : {
            open : 5,
            close : 4,
        },
        saturday : {
            open : 8,
            close : 12,
        },
    }
}

// to destructure obj use the curly braces
// the order desn't matter for this

// const {name, openingHours, catagories} = restaurant
// three new variables created from the restaurant obj

// console.log(name)
// console.log(openingHours)
// console.log(catagories)

// --->

// string ---> classico italiano
// obj ---> {thursday: {…}, friday: {…}, saturday: {…}}
// arr ---> ['italian', 'pizzaria', 'organic']

// you can rename the variables destructured
const {name: restaurantName, openingHours: hours, catagories: tags} = restaurant
console.log(restaurantName)
console.log(hours)
console.log(tags)

// string ---> classico italiano
// obj ---> {thursday: {…}, friday: {…}, saturday: {…}}
// arr ---> ['italian', 'pizzaria', 'organic']

// mutating variables
let a = 111
let b = 999

const obj = {a : 23, b : 7, c : 14}

// need ()
({a,b} = obj)
console.log(a,b)

~~~~~~~~~~~
let a = 111;
let b = 999;
const obj = { a: 23, b: 7, c: 14};
({a, b} = obj);
console.log(a, b);

---> 23 7

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    openingHours: {
        thursday : {
            open : 5,
            close : 5,
        },
        friday : {
            open : 5,
            close : 4,
        },
        saturday : {
            open : 8,
            close : 12,
        },
    }
}

// netsed object destructuring
//const {friday, saturday} = restaurant.openingHours
//console.log(friday)
//console.log(saturday)

//--->
//(fri) {open: 5, close: 4}
//(sat) {open: 8, close: 12}

const {friday: {open: o, close: c}, saturday: {open : so, close: sc} } = restaurant.openingHours;
console.log(o,c)
console.log(so,sc)

---> 5 4
---> 8 12
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , ' bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    openingHours: {
        thursday : {
            open : 5,
            close : 5,
        },
        friday : {
            open : 5,
            close : 4,
        },
        saturday : {
            open : 8,
            close : 12,
        },
    },

    orderDelivery: function({ starterIndex, mainIndex, deliverytime, address}) {
        console.log(`order recieved : ${this.startMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be deliverd to ${address} at time ${deliverytime}`)
    },
}

// passing in an obj into a method of another obj
// you can do destructuring right away
// calling a method with an object

restaurant.orderDelivery ({
    deliverytime : '10pm',
    address : 'via del sole ,21',
    mainIndex: 2,
    starterIndex: 2,
})

--->
---> order recieved : bread and risotto will be deliverd to via del sole ,21 at time 10pm

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Spread Operator (...)
can unpack all array elements at once

const arr = [7, 8, 9];

const newarr = [1 , 2, ...arr];
console.log(newarr)

---> [1, 2, 7, 8, 9]

console.log(...newarr)
---> 1 2 7 8 9

// whenever you need the individual elements of an array use the spread operator

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , 'bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
}

// we are creating a new arr, NOT mainipulating the existing arr
// you could mainipulate the arr by using the push() method

//const newMenu = [...restaurant.mainMenu, 'Gnocci'];
//console.log(newMenu)

//---> ['pizza', 'pasta', 'risotto', 'Gnocci']
// copy array

//const mainMenuCopy = [...restaurant.mainMenu];

// join 2 arrays or more
const menu = [...restaurant.mainMenu, ...restaurant.startMenu]
console.log(menu)

// ---> ['pizza', 'pasta', 'risotto', 'focaccia', 'bruschetta', 'bread']

// the spread operator works on all iterables 
// that means arrays, strings, maps, sets

const name = 'andrew'
const letters = [...name]
console.log(letters)
// --->  ['a', 'n', 'd', 'r', 'e', 'w']
~~~~~~~~~~~~~~~~~~~~~~~

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , 'bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],

    orderPasta : function(ingredient1 , ingredient2, ingredient3) {
        console.log(`here\'s your pasta with ${ingredient1}, ${ingredient2}, ${ingredient3}`)
    }
}

const ingredientsArr = ['olives','shrimp','cheese']

// using the order pasta method in restaurant obj
// using the spread operator to pass in all items in the array to the arguments of the method

restaurant.orderPasta(...ingredientsArr)

// ---> here's your pasta with olives, shrimp, cheese

~~~~~~~~~~~~~~~~~~~~~~~
// you can use the spread operator on objects to create new objects 

const restaurant = {
    name : 'classico italiano' ,
    location : 'via angelo tavanti 23, firenze, italy' ,
    catagories : ['italian','pizzaria','organic'] ,
    startMenu : ['focaccia' , 'bruschetta' , 'bread'] ,
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
}

const newRest = {...restaurant, founder: 'Andrew'}
console.log(newRest.mainMenu[1], newRest.founder)

// ---> pasta, Andrew
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Rest Pattern and Parameters

will collect multiple elements and condense them into the same array
opposite of spread operator

// RECAP of spread, the dots are on the Right side of the = sign
const arr = [1,2,...[3,4]]

// destructuring you can use REST operator syntax
// LEFT side of the = sign
const [a,b, ...others] = [1,2,3,4,5]
console.log(a)
console.log(b)
console.log(others)

---> 1
---> 2
---> [3, 4, 5]


*** REST - instructs the computer to add whatever otherInfo (arguments) supplied by the user into an array
*** Spread - takes in an iterable (e.g an array) and expands it into individual elements


Rest will take the rest of the elements of an arr and assign them to a new arr - used with destructuring
const [a,b, ...others] = [1,2,3,4,5]

const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
}

// using SPREAD and REST 
// destructuring the main menu and startmenu using spread into variables pizza, pasta and using the REST operator to assign everything else to an arr
// spread is used to assign everything from this array to a variable
// rest is used to assign everything else in the array to a variable

const [pizza, pasta, ...otherfood ] = [...restaurant.mainMenu, ...restaurant.startMenu]

console.log(pizza, pasta)
console.log(otherfood)

---> pizza pasta
---> ['risotto', 'focaccia', 'bruschetta', 'bread']

// This also works with objects as well

// Objects 

// created a restaurant obj with another obj named openingHours
const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
    openingHours : {
        thursday : {
            open : '5am',
            close : '5pm',
        },
        friday : {
            open : '5am',
            close : '3pm',
        },
        saturday : {
            open : '8am',
            close : '8pm',
        },
    },
}

// deconstructing restaurant.openingHours into saturday and also weekdays using the rest pattern
const {saturday, ...weekdays} = restaurant.openingHours

console.log(saturday.close)
console.log(weekdays.thursday.close)
console.log(weekdays.friday.close)

// ---> 
// 8pm
// 5pm
// 3pm

// for the spread operator, another use case was to pass multiple arguments into function all at the same time

// use of rest operator to pack everything into one array 
const add = function(...numbers) {
    let sum = 0;
    for (let i = 0; i < numbers.length; i++) {
        sum += numbers[i]
    }

    console.log(sum)
}

let arr = [3,4,5,6,7,8,9]

// use of spread operator
add(1,2, ...arr)

---> 45

ex. orderPizza : function( mainIngredient, ...otherIngredients) {
}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Classes - blueprints for creating objects

class Student {

    constructor(name) {
        this.name=name;
    }

    displayName() {
        console.log(`this student's name is ${this.name}`)
    }

}

let studentOne = new Student('Andrew Brase');
studentOne.displayName()

let studentTwo = new Student('bob smith')
studentTwo.displayName()

--->    this student's name is Andrew Brase
--->    this student's name is bob smith
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class Person {

    constructor (name,age,height) {
        this.name = name
        this.age = age
        this.height = height
    }

    displayInfo() {
        console.log(`this persons name is ${this.name}, they are ${this.age} years old and they are ${this.height} tall`)
    }
}

let Tim = new Person ('Tim',25,'6ft')
let James = new Person ('James',44,'5ft')

Tim.displayInfo()
James.displayInfo()

--->    this persons name is Tim, they are 25 years old and they are 6ft tall
--->    this persons name is James, they are 44 years old and they are 5ft tall

//
console.log(Tim.age) ---> 25
console.log(James.age) ---> 44

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Inheritance

class Car {
    constructor(brand) {
        this.carname = brand
    }

    present() {
        return `I have a ${this.carname}`
    }
}

class Model extends Car {
    constructor( brand, mod ) {
        super(brand);
        this.model = mod
    }

    show() {
        console.log(this.present() + `, it is a ${this.model}`)
    }
}

mycar = new Model('Ford','Mustang')
mycar.show()
---> I have a Ford, it is a Mustang
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Short Circuiting (&& and ||)

// and & or operators can return any data type, not just boolean

/* in the case of the or operator short circuiting means that if 
the first value is a truthy value it will immediately return the first value */

console.log(3 || 'andrew')
// ---> 3

console.log(false || 'andrew')
// ---> 'andrew'

console.log('' || 'andrew')
// ---> 'andrew'

console.log(0 || true)
// ---> true

console.log(undefined || null)
// ---> null

~~~
Turnery Operator
const restaurant = {}
const guests = restaurant.numGuests ? restaurant.numGuests : 10;
console.log(guests)

// restaurant.numGuests is undefined
// ---> 10

const result = 10 % 2 === 0 ? 'that is true' : 'that is false'
console.log(result)

// ---> 'that is true'

const newresult = 5 * 5 === 0 ? 0 : 25;
console.log(newresult)

// ---> 25

// so instead of doing this we can take advantage of short circuiting and the OR operator
const restaurant = {}
const guests = restaurant.numGuests || 10
console.log(guests)
// ---> 10

~~~~~~~~~~~~~~~~~~~~~~~
// the && operator will return the first falsy value

console.log(0 && 'andrew')
// ---> 0

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Nullish coalescing operator (??)

// returns its right-hand side operand when its left-hand side operand is 
// null or undefined

const result = null ?? 'andrew'
console.log(result)

// ---> 'andrew'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Logical Assignment Operators

const rest1 = {
    name : 'Capri',
    numGuest : 20,
}

const rest2 = {
    name : 'La Piazza',
    owner : 'Giovanni Rossi',
}

// ~~~~~~~~~~~~~~~~~~~~~~~~
// The OR assignment operator
// this operator assigns a value to a variable if that variable is currently falsy 

// rest1.numGuest = rest1.numGuest || 10
// ---> 20

// numGuest is not in rest 2 obj making it falsy
// rest2.numGuest = rest2.numGuest || 10
// ---> 10

// This can be written as 

rest1.numGuest ||= 10
// ---> 20

rest2.numGuest ||= 10
// ---> 10

console.log(rest1)
console.log(rest2)

{name: 'Capri', numGuest: 20}

//                                               !!!
{name: 'La Piazza', owner: 'Giovanni Rossi', numGuest: 10}

~~~~~~~~~~~~~~~~~~~~~~~~
The Nullish Assignment Operator (nullish means null or undefined)
// assign a value to a variable if that variable is currently nullish

rest1 = {
    numGuest : 0
}

rest2 = {
    name : 'andrew'
}

rest1.numGuest ??= 10;
rest2.numGuest ??= 10;

console.log(rest1)
console.log(rest2)

// --->
{numGuest: 0}
{name: 'andrew', numGuest: 10}


~~~~~~~~~~~~~~~~~~~~~~~~
The AND assignment Operator
// is there currently is an owner, you could anonymize the name
//  assign a value to a variable if it is currently truthy (it exists)

rest1 = {
    ownerName : 'andrew'
}

rest2 = {
    food : 'pasta'
}

// rest1.ownerName &&= 'anon'
// console.log(rest1)
// ---> {ownerName: 'anon'}

rest2.ownerName &&= 'anon'
// ---> undefined
// (there is no ownerName in rest2)
console.log(rest2)
// ---> {food: 'pasta'}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Looping Arrays: The for-of Loop

const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
}

const menu = [...restaurant.mainMenu , ...restaurant.startMenu]

//for (const food of menu) console.log(food)

// --->
//pizza
//pasta
//risotto
//focaccia
//bruschetta
//bread

// this method not as good getting the index

//for (const item of menu.entries()) {
    //console.log(item)
    // this will make every element an array with the [index, value]
//}

// --->
// [0, 'pizza']
// [1, 'pasta']
// [2, 'risotto']
// [3, 'focaccia']
// [4, 'bruschetta']
// [5, 'bread']

for (const item of menu.entries()) {
    console.log(item[0])
    // this will make every element an array with the [index, value]
}

// --->
// 0
// 1
// 2
// 3
// 4
// 5


// we can use destructuring to make this easier

const restaurant = {
    mainMenu : ['pizza' , 'pasta' , 'risotto' ],
    startMenu : ['focaccia' , 'bruschetta' , 'bread'],
}

const menu = [...restaurant.mainMenu , ...restaurant.startMenu]

for (const [index, element] of menu.entries()) {
    console.log(`${index} : index , ${element} : element`)
}

// --->
0 : index , pizza : element
1 : index , pasta : element
2 : index , risotto : element
3 : index , focaccia : element
4 : index , bruschetta : element
5 : index , bread : element
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Optional Chaining (.?)
// feature of objects and arrays

const restaurant = {
    openingHours : {
        // missing Monday
        tue : {
            open : '5am',
            close : '5pm',
        },
        wed : {
            open : '5am',
            close : '5pm',
        },
        thu : {
            open : '5am',
            close : '5pm',
        },
        fri : {
            open : '5am',
            close : '3pm',
        },
        sat : {
            open : '5am',
            close : '10pm',
        },
        sun : {
            open : '5am',
            close : '10pm',
        },
    },
};
console.log(restaurant.openingHours?.tue?.open)

console.log(restaurant.openingHours.mon.open)
// ---> Cannot read properties of undefined

// this is just checking for ONE property Monday
if (restaurant.openingHours.mon) console.log(restaurant.openingHours.mon.open)

// with Optional chaining, if a certain property does not exist, 
// then undefined is returned immediately 

// WITH optional chaining 
// only if monday? exists then the open property will be read, if not undefined will be returned

console.log(restaurant.openingHours.mon?.open)
// ---> undefined

we can do the same for opening hours
console.log(restaurant.openingHours?.tue?.open)
// ---> 5am
